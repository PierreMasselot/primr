% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/peeling_trajectory.R
\name{cv.trajectory}
\alias{cv.trajectory}
\title{Cross-validated peeling trajectory}
\usage{
cv.trajectory(y, x, beta.stop.grid = NULL, folds = NULL, nfolds = 10,
  ...)
}
\arguments{
\item{y}{Numeric vector of response values.}

\item{x}{Numeric or categorical data.frame of input values.}

\item{beta.stop.grid}{Vector of stopping supports
for peeling trajectory prediction.
If NULL (the default), an initial peeling is carried out on the 
whole data and its \code{support} element is used.}

\item{folds}{An integer vector giving the fold index of each observation.
If NULL (the default)
\code{nfolds} folds are randomly generated. Directly using \code{folds}
is useful for nonstandard folds such as blocks. Note that \code{folds} is 
recycled if necessary.}

\item{nfolds}{Integer giving the number of folds to create if \code{folds}
is NULL.}

\item{...}{Additional arguments to be passed to \code{\link{peeling}}.}
}
\value{
A \code{cv.prim} object that can be used in methods for \code{prim}
   objects (e.g. \code{\link{plot_trajectory}}). Contains the elements:
   \item{support}{The support grid provided in the argument 
     \code{beta.stop.grid} or generated if the latter is \code{NULL}.}
   \item{yfun}{The cross-validated objective function values at each
     \code{support} value.}
   \item{se.yfun}{Cross-validation standard errors associated with 
     \code{yfun} values.}
   \item{x,y}{The input and response data used.}
   \item{numeric.vars}{A logical vector indicating, for each input variable,
     if it was considered as a numeric variable.}
   \item{alpha, peeling.side, obj.fun}{The value of the arguments used for
     peeling. Useful for prim methods.}
}
\description{
Performs k-fold cross-validation on peeling for choosing the stopping 
   criterion.
}
\details{
The \code{cv.trajectory} function splits the provided data into
   \code{nfolds} several folds. The peeling is carried out on 
   \code{nfolds - 1} folds and the objective function is computed on the
   remaining fold. This process is repeated excluding each fold successively
   and the resulting trajectories are averaged at each value in 
   \code{beta.stop.grid}.

   Folds can be given either directly through the argument \code{folds} or 
   randomly generated using the argument \code{nfolds}.
}
\examples{
   # A simple bump
   set.seed(12345)
   x <- matrix(runif(2000), ncol = 2, dimnames = list(NULL, c("x1", "x2")))
   y <- 2 * x[,1] + 5 * x[,2] + 10 * (x[,1] >= .8 & x[,2] >= .5) + rnorm(1000)
   
   # 10-fold cross-validation
   cv_res <- cv.trajectory(y, x)
   
   # Display the cross-validated trajectory
   plot_trajectory(cv_res, type = "b", pch = 16, col = "cornflowerblue", 
     support = 0.1, npeel = which.max(cv_res$yfun), 
     abline.pars = list(lwd = 2, col = "indianred"), 
     xlab = "", xlim = c(0, 0.2), ylim = c(10, 18))

}
\references{
Friedman, J.H., Fisher, N.I., 1999. Bump hunting in high-dimensional data.
     Statistics and Computing 9, 123-143. 
     https://doi.org/10.1023/A:1008894516817
}
\seealso{
\code{\link{peeling}} for the peeling algorithm used in the
   function. \code{\link{plot_trajectory}} to analyse the cross-validated
   trajectory.
}
